var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [SpatialHashTables]","category":"page"},{"location":"api/#SpatialHashTables.AbstractSpatialHashTable","page":"API","title":"SpatialHashTables.AbstractSpatialHashTable","text":"AbstractSpatialHashTable\n\nAbstract type for spatial hash tables.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpatialHashTables.BoundedHashTable","page":"API","title":"SpatialHashTables.BoundedHashTable","text":"BoundedHashTable\n\nA spatial hash table with a fixed domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpatialHashTables.BoundedHashTable-Tuple{AbstractVector, Vararg{Any}}","page":"API","title":"SpatialHashTables.BoundedHashTable","text":"BoundedHashTable(X::AbstractVector, args...)\n\nConstructs a BoundedHashTable with length(X) particles and calls  updatetable!(ht, X) to update the hash table.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.BoundedHashTable-Tuple{Int64, Any, Any}","page":"API","title":"SpatialHashTables.BoundedHashTable","text":"BoundedHashTable(N::Integer, grid::Tuple, range::AbstractVector)\n\nConstructs a BoundedHashTable with N particles, a grid size of grid and a domain from zero(range) to range. See details of the main constructor for more information.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.BoundedHashTable-Tuple{Int64, Number, Any, Any}","page":"API","title":"SpatialHashTables.BoundedHashTable","text":"BoundedHashTable(N::Int64, cellsize::Number, domainstart, domainend)\n\nSame as previous constructor, but allowing the domain to be specified by Vector{Float64} or NTuple{Dim,Float64} instead of StaticVectors. cellsize determines the cell size in each dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.BoundedHashTable-Tuple{Int64, Number, StaticArraysCore.SVector, StaticArraysCore.SVector}","page":"API","title":"SpatialHashTables.BoundedHashTable","text":"BoundedHashTable(N::Int64, cutoff::Number, domainstart::SVector, domainend::SVector)\n\nConstructs a BoundedHashTable with N particles. The cell size is close to cutoff (or slightly larger)  in each dimension. The domain ranges from domainstart to domainend.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.BoundedHashTable-Tuple{Integer, Any, Any, Any}","page":"API","title":"SpatialHashTables.BoundedHashTable","text":"BoundedHashTable(N::Integer, grid, domainstart, domainend)\n\nSame as the main constructor, but allowing the domain to be specified by Vector{Float64}  or NTuple{Dim,Float64} instead of StaticVectors\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.BoundedHashTable-Tuple{Integer, Tuple, StaticArraysCore.SVector, StaticArraysCore.SVector}","page":"API","title":"SpatialHashTables.BoundedHashTable","text":"BoundedHashTable(N::Integer, grid::Tuple, domainstart::SVector, domainend::SVector)\n\nPrimary constructor for a BoundedHashTable with N particles, a grid size of grid and  a domain from domainstart to domainend. The grid is a tuple of size Dim which  determines the number of cells along each dimension.\n\nWe refer to the other constructors for more convenient ways to construct a BoundedHashTable.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.SpatialHashTable","page":"API","title":"SpatialHashTables.SpatialHashTable","text":"SpatialHashTable\n\nA spatial hash table for unbounded domains. See Matthias Müller's paper for more information of the method used.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpatialHashTables.SpatialHashTable-Tuple{AbstractVector, Number, Int64, Vararg{Any}}","page":"API","title":"SpatialHashTables.SpatialHashTable","text":"SpatialHashTable(X::AbstractVector, cutoff::Number, tablesize::Int64, args...)\n\nConstructs a SpatialHashTable with length(X) particles and calls  updatetable!(ht, X) to update the hash table. The cutoff determines the cell size along each dimension and the Dim is inferred from the first particle in X. (Alternatively one can provide a SVector of size Dim or a NTuple{Dim,Float64}.) \n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.SpatialHashTable-Tuple{AbstractVector, Vararg{Any}}","page":"API","title":"SpatialHashTables.SpatialHashTable","text":"SpatialHashTable(X::AbstractVector, cutoff::Number, tablesize::Int64, args...)\n\nConstructs a SpatialHashTable with length(X) particles and calls  updatetable!(ht, X) to update the hash table.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.SpatialHashTable-Tuple{Int64, Any, Int64, Vararg{Any}}","page":"API","title":"SpatialHashTables.SpatialHashTable","text":"SpatialHashTable(N::Integer, cellsize, tablesize::Integer; args...)\n\nSame as the main constructor, but allowing the cell size to be specified by a tuple of size Dim.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.SpatialHashTable-Tuple{Int64, Number, Int64, Int64, Vararg{Any}}","page":"API","title":"SpatialHashTables.SpatialHashTable","text":"SpatialHashTable(N::Integer, cutoff::Number, Dim::Integer, tablesize::Integer; args...)\n\nSame as the main constructor, but allowing the cell size to be specified by a number cutoff and the spatial dimension Dim.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.SpatialHashTable-Tuple{Int64, StaticArraysCore.SVector, Int64}","page":"API","title":"SpatialHashTables.SpatialHashTable","text":"SpatialHashTable(N::Integer, cellsize::SVector, tablesize::Integer; cachesize=Threads.nthreads(), pseudorandomfactors=default_factors)\n\nPrimary constructor for a SpatialHashTable with N particles, a table size of tablesize and a cell size of cellsize. The table size determines the number of cells in the hash table. The cell size is a SVector of size Dim which determines the size of each cell along each dimension.\n\nAdditionally, the cachesize determines the number of thread-local caches used for the hash table. Once can set cachesize=1 for single threaded applications.\n\nThe pseudorandomfactors are used to generate a hash index for each particle. The default values are taken from Matthias Müller's paper.\n\n\n\n\n\n","category":"method"},{"location":"api/#Adapt.adapt_structure-Tuple{Any, BoundedHashTable}","page":"API","title":"Adapt.adapt_structure","text":"Adapt.adapt_structure(to, ht::AbstractSpatialHashTable)\n\nAdapts the hash table ht to the type to. This is useful for GPU support.\n\nIt automatically converts types to Float64 and Int32!\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.resize!-Tuple{AbstractSpatialHashTable, Any}","page":"API","title":"Base.resize!","text":"resize!(ht::AbstractSpatialHashTable, n_positions)\n\nResizes the hash table ht to accomodate n_positions particles. This method is useful if the number of particles changes over time. \n\nThis call should usually be followed by a call to updatetable! to update the hash table. Without updatetable! the hash table will be in an inconsistent state.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.dimension-Union{Tuple{SpatialHashTable{Dim}}, Tuple{Dim}} where Dim","page":"API","title":"SpatialHashTables.dimension","text":"dimension(ht::AbstractSpatialHashTable)\n\nReturns the spatial dimension of a hash table.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.hashposition-Tuple{AbstractSpatialHashTable, Any}","page":"API","title":"SpatialHashTables.hashposition","text":"hashposition(ht::AbstractSpatialHashTable, pos)\n\nReturns the hash position of pos in the hash table ht.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.insidegrid-Tuple{BoundedHashTable, Any}","page":"API","title":"SpatialHashTables.insidegrid","text":"inside(ht::AbstractSpatialHashTable, pos)\n\nReturns true if pos is inside the domain of the hash table ht.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.inttype-Tuple{AbstractSpatialHashTable}","page":"API","title":"SpatialHashTables.inttype","text":"inttype(ht::AbstractSpatialHashTable)\n\nReturns the integer type used for indexing the hash table. (Useful for GPU support.)\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.iterate_box-Tuple{AbstractSpatialHashTable, Any}","page":"API","title":"SpatialHashTables.iterate_box","text":"iterate_box(ht::AbstractSpatialHashTable, boxhash)\n\nReturns an iterator over the particles in the box with hash boxhash in the hash table ht.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.neighbouring_boxes-Tuple{AbstractSpatialHashTable, Any, Any}","page":"API","title":"SpatialHashTables.neighbouring_boxes","text":"neighbouring_boxes(ht::AbstractSpatialHashTable, gridpos, r)\n\nReturns an iterator over the neighbouring boxes of the box with grid position gridpos in the hash table ht. r determines the radius of the neighbourhood.\n\nThe gridpos is a tuple of size Dim which determines the position of a box in lattice  with basis vectors ht.inv_cellsize.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.neighbours-Tuple{AbstractSpatialHashTable, Any, Any}","page":"API","title":"SpatialHashTables.neighbours","text":"neighbours(ht::AbstractSpatialHashTable, pos, r)\n\nReturns an iterator over the particles in the neighbourhood of pos in the hash table ht. r determines the radius of the neighbourhood.\n\nThis is the main method of this package and is used to find the neighbours of a particle.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpatialHashTables.updatetable!-Tuple{AbstractSpatialHashTable, Any}","page":"API","title":"SpatialHashTables.updatetable!","text":"updatetable!(ht::AbstractSpatialHashTable, X)\n\nUpdates the hash table ht with the positions X of the particles.\n\nThis method is linear in the number of particles and should generally not allocate.\n\nThe ideal datatype for X is Vector{SVector{Dim,FT}} where Dim is the spatial dimension and FT is the floating point type.\t\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SpatialHashTables","category":"page"},{"location":"#SpatialHashTables","page":"Home","title":"SpatialHashTables","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SpatialHashTables.","category":"page"},{"location":"#Core-interface","page":"Home","title":"Core interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are essentially four functions which are needed to use the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The typical constructors have inputs which determine: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"the number of particles or the particles themselves\nthe spatial size of the cells\nthe number of hash indices (only for SpatialHashTable)\nthe domain (only for BoundedHashTable)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core functions are BoundedHashTable and SpatialHashTable which create the hash tables. The hash tables are then updated via updatetable! and once can iterate neigbours of a given position with the neighbours function.","category":"page"},{"location":"#BoundedHashTable","page":"Home","title":"BoundedHashTable","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The easiest constructor is BoundedHashTable(X, r, domain), where X is a vector of particle positions, r is the spatial size of the cells, and domain is the upper bounde for the domain of the particles.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using StaticArrays, SpatialHashTables\nbht = BoundedHashTable(100, 0.1, (1.0, 2.0))","category":"page"},{"location":"","page":"Home","title":"Home","text":"To update the table for given positions, one can call updatetable!:","category":"page"},{"location":"","page":"Home","title":"Home","text":"X = rand(SVector{Float64,3}, 100)\nupdatetable!(bht, X)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where X is a vector of particle positions. This is done in mathcalO(n) time and allocation free.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Iteration over all neigbours of a given position x is done via neighbours(bht, p, r):","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = @SVector [0.5, 0.5, 0.5]\nr = 0.2\n\nfor j in neighbours(bht, p, r)\n    d² = sum(x -> x^2, X[j] - p)\n\n    if d² < r^2\n        # do something with X[j]\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"where p is a position and r is the cutoff distance. Notice that the cutoff distance  can be larger than the cell size during construction. In this case more cells will be visited during the iteration.","category":"page"},{"location":"#SpatialHashTable","page":"Home","title":"SpatialHashTable","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The constructor SpatialHashTable(X, tablesize, r) is similar to BoundedHashTable, but does not require a domain but instead the number of hash indices tablesize:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using StaticArrays, SpatialHashTables\n\nX = rand(SVector{Float64,3}, 1000)\ntablesize = 1000\nsht = SpatialHashTable(X, 0.1, tablesize)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This creates a hash table with tablesize many hash indices. The number of hash indices should be chosen such that the number of particles per hash index is not too small. Due to the hashing, it can happen that  particles with large distance are assigned to the same hash index. This can be avoided by choosing a larger tablesize.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Too large tablesize can lead to a large memory footprint.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Moreover, by providing the positions X instead of the number of particles as the first input, the constructor will automatically call updatetable! to update the hash table.  The same holds for constructors of BoundedHashTable.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using the hash table is similar to BoundedHashTable. Let us iterate here over all  pairs of points within a given radius r:","category":"page"},{"location":"","page":"Home","title":"Home","text":"r = 0.05\nfor i in eachindex(X)\n    for j in neighbours(sht, X[i], r)\n        d² = sum(x -> x^2, X[i] - X[j])\n\n        if d² < r^2\n            # do something with X[j]\n        end\n    end\nend","category":"page"},{"location":"#CPU-Parallelization","page":"Home","title":"CPU Parallelization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The above code snippets are for serial CPU computations.  For parallel computations, one has to write small parallelization boilder code.  However, this approach provides in return flexibility and control.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Provided that julia is started with multiple threads, one can use Threads.@threads to parallelize the code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"res_mt = zeros(Threads.nthreads())\n\nThreads.@threads for i in eachindex(X)\n    for j in neighbours(sht, X[i], r)\n        d² = sum(x -> x^2, X[i] - X[j])\n\n        if d² < r^2\n            res_mt[Threads.threadid()] += sqrt(d²)\n        end\n    end\nend\n\nres = sum(res_mt)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where res_mt is a vector of length Threads.nthreads() which stores the partial results of each thread. The final result is then the sum of the partial results.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This simple code snippet can be easily adapted to other computations. One example would be  to compute forces for all particles given a potential function V:","category":"page"},{"location":"","page":"Home","title":"Home","text":"F = zeros(SVector{Float64,3}, length(X))\nV(d) = 1/d^3\n\nThreads.@threads for i in eachindex(X)\n    for j in neighbours(sht, X[i], r)\n        d² = sum(x -> x^2, X[i] - X[j])\n\n        if d² < r^2\n            F[i] += (X[i] - X[j]) * V(sqrt(d²))\n        end\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the code runs over all particles i and then over all neighbours j of i. For some computations one might add a check if i == j to avoid self-interactions or i < j to avoid double counting.","category":"page"},{"location":"#GPU-Parallelization","page":"Home","title":"GPU Parallelization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is not fully optimized for GPUs.  However, here is a simple example how to use the package on GPUs via CUDA.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CUDA, StaticArrays, SpatialHashTables\n\nX = rand(CuArray{SVector{Float64,3}}, 1000)\ncellsize = 1/N^(1/3)\n\nht = BoundedHashTable(X, cellsize, (1.0, 1.0, 1.0))\n\nr = 0.05\n\nX_gpu = cu(X)\nbht_gpu = cu(ht)\n\nfunction gpu_kernel!(ht_gpu, X, r, res)\n    index = (blockIdx().x - 1i32) * blockDim().x + threadIdx().x\n    stride = gridDim().x * blockDim().x\n\n    for i in index:stride:Int32(length(X))\n        res[i] = 0.0f0\n        for j in neighbours(ht_gpu, X[i], r)        \n            d2 = dist_sq(X[i], X[j])  \n            res[i] += ifelse(i < j && d2 < r^2, 1.0f0, 0.0f0)\n        end\n    end\n    return nothing\nend\n\nres = CUDA.zeros(Float32, length(X))\n\nfunction compute_on_gpu(ht_gpu, X_gpu, r, res)\n\n    # determine number of threads and blocks\n    kernel = @cuda launch = false  gpu_kernel!(ht_gpu, X_gpu, r, res)\n    config = launch_configuration(kernel.fun)\n    threads = min(length(X_gpu), config.threads)\n    blocks = cld(length(X_gpu), threads)\n\n    # run kernel\n    CUDA.@sync begin \n        kernel(ht_gpu, X_gpu, r, res; threads, blocks)\n    end\n\n    # reduce step\n    return sum(res)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"At this point in thime, the performance of the GPU code is not better than of parallel CPU code.","category":"page"}]
}
